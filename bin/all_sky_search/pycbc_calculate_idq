#!/usr/bin/env python
""" Ingest and cluster iDQ data
"""
import logging, argparse, numpy, h5py, multiprocessing, time, copy
from six.moves import (range, zip_longest)
import pycbc, pycbc.psd, pycbc.strain, pycbc.events
from pycbc.version import git_verbose_msg as version
from pycbc.fft.fftw import set_measure_level
from pycbc.workflow import resolve_td_option
from ligo.segments import segmentlist, segment
set_measure_level(0)

parser = argparse.ArgumentParser(description=__doc__)
parser.add_argument('--version', action='version', version=version)
parser.add_argument('--verbose', action="store_true")
parser.add_argument("--idq-sample-rate", default=1, type=int)
parser.add_argument("--gps-start-time", type=int,required=True)
parser.add_argument("--gps-end-time", type=int,required=True)
parser.add_argument("--output-file", required=True)

pycbc.strain.insert_strain_option_group(parser, gps_times=False)

args = parser.parse_args()
pycbc.init_logging(args.verbose)

def get_idq(seg):
    """ Get the PSDs for the given data chunck. This follows the same rules
    as pycbc_inspiral for determining where to calculate PSDs
    """
    
    logging.info('Getting idq values for %.1f-%.1f (%.1f s)', seg[0],
                 seg[1], abs(seg[1]-seg[0]))
    argstmp = copy.deepcopy(args)
    argstmp.gps_start_time = int(seg[0])
    argstmp.gps_end_time = int(seg[1])
    tmp_segment = segment([argstmp.gps_start_time, argstmp.gps_end_time])
    argstmp.channel_name = resolve_td_option(args.channel_name, tmp_segment)

    # This helps when the filesystem is unreliable, and gives extra retries.
    # python has an internal limit of ~100 (it is not infinite)
    try:
        gwstrain = pycbc.strain.from_cli(argstmp)
    except RuntimeError:
        time.sleep(10)
        return get_psd(seg)

    logging.info('Normalizing idq values for %.1f-%.1f (%.1f s)', seg[0],
                 seg[1], abs(seg[1]-seg[0]))

    idq_sample_rate = float(args.idq_sample_rate) 
    idq_step_size = gwstrain.sample_rate/idq_sample_rate

    # maximize gwstrain over 1 sec interval
    max_idq = numpy.array([max(gwstrain.numpy()[int(n*idq_step_size):int((n+1)*idq_step_size)])
               for n in numpy.arange(0,len(gwstrain.numpy())/idq_step_size)])


    # figure out list of times
    times_idq = numpy.arange(gwstrain.start_time,gwstrain.end_time,1./idq_sample_rate)

    return max_idq, times_idq

ifo = args.channel_name[0:2]

idq = get_idq((args.gps_start_time,args.gps_end_time))

f = h5py.File(args.output_file, 'w')
start, end = [args.gps_start_time], [args.gps_end_time]

f[ifo + '/start_time'] = numpy.array(start, dtype=numpy.uint32)
f[ifo + '/end_time'] = numpy.array(end, dtype=numpy.uint32)
f[ifo + '/log_likelihood'] = numpy.array(idq[0], dtype=numpy.float32)
f[ifo + '/times'] = numpy.array(idq[1], dtype=numpy.uint32)

logging.info('Done!')

